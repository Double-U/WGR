/*
 * 2010/11/04
 * Changed new Column to use ByteBuffer's instead of byte[]
 * Why they changed to ByteBuffers: no one knows apparently
 */
package net.wgr.core.dao;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import net.wgr.core.data.DataPool;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import net.wgr.core.ReflectionUtils;
import net.wgr.core.data.ColumnFamily;
import net.wgr.settings.Settings;
import org.apache.cassandra.thrift.Column;
import org.apache.cassandra.thrift.ConsistencyLevel;
import org.apache.commons.codec.binary.StringUtils;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.scale7.cassandra.pelops.Bytes;
import org.scale7.cassandra.pelops.Mutator;
import org.scale7.cassandra.pelops.RowDeletor;
import org.scale7.cassandra.pelops.Selector;

/**
 * Data Access Object
 * Reflection in Java is pure awesomeness
 * @author DoubleU
 */
public abstract class Object {
    
    public void insert() {
        try {
            byte[] keyFieldValue = null;
            ArrayList<Column> columns = new ArrayList<>();
            
            prepareForStorage();
            
            Mutator m = DataPool.getMutator();
            
            for (Field f : ReflectionUtils.getAllFields(this.getClass())) {
                try {
                    f.setAccessible(true);

                    // It is the non-public fields we're after
                    if (Modifier.isPublic(f.getModifiers())) {
                        continue;
                    }

                    // It's transient for a reason
                    if (Modifier.isTransient(f.getModifiers())) {
                        continue;
                    }
                    
                    if (Map.class.isAssignableFrom(f.getType())) {
                        Map<String, String> map = (Map) f.get(this);
                        ArrayList<Column> cols = new ArrayList<>();
                        
                        for (Map.Entry<String, String> entry : map.entrySet()) {
                            Column col = new Column();
                            col.setName(ByteBuffer.wrap(entry.getKey().getBytes("UTF-8")));
                            col.setValue(ByteBuffer.wrap(entry.getValue().getBytes("UTF-8")));
                            col.setTimestamp(System.currentTimeMillis());
                            cols.add(col);
                        }

                        // keyFieldValue can and will be null
                        m.writeSubColumns(getColumnFamily(), Bytes.fromByteArray(keyFieldValue), Bytes.fromUTF8(f.getName()), cols);
                        continue;
                    }
                    
                    Column nc = new Column(ByteBuffer.wrap(f.getName().getBytes(Charset.forName("UTF-8"))));
                    nc.setTimestamp(System.currentTimeMillis());
                    if (f.getType().getName().equals("java.lang.String")) {
                        String val = (String) f.get(this);
                        if (val == null) {
                            continue;
                        }
                        nc.setValue(val.getBytes(Charset.forName("UTF-8")));
                    } else if (f.getType().getName().equals("int")) {
                        int i = f.getInt(this);
                        if (i == 0 && f.isAnnotationPresent(AutoGenerated.class)) {
                            if (f.getAnnotation(AutoGenerated.class).strategy() == AutoGenerated.GenerationStrategy.SEQUENTIAL) {
                                i = (int) (ColumnFamily.getKeyCount(this.getColumnFamily()) + 1);
                                f.setInt(this, i);
                            }
                        }
                        Bytes b = Bytes.fromInt(i);
                        nc.setValue(b.getBytes());
                    } else if (f.getType().getName().equals("boolean")) {
                        nc.setValue(ByteBuffer.wrap(new byte[]{(byte) (f.getBoolean(this) ? 1 : 0)}));
                    } else if (f.getType().getName().equals("long")) {
                        long l = f.getLong(this);
                        if (l == 0 && f.isAnnotationPresent(AutoGenerated.class)) {
                            if (f.getAnnotation(AutoGenerated.class).strategy() == AutoGenerated.GenerationStrategy.SEQUENTIAL) {
                                l = ColumnFamily.getKeyCount(this.getColumnFamily()) + 1;
                                f.setLong(this, l);
                            }
                        }
                        nc.setValue(Bytes.fromLong(l).getBytes());
                    } else if (f.getType().getName().equals("java.util.UUID")) {
                        if (f.isAnnotationPresent(TimeUUID.class)) {
                            UUID uuid = (UUID) f.get(this);
                            nc.setValue(Bytes.fromTimeUuid(uuid).getBytes());
                        } else {
                            UUID uuid = (UUID) f.get(this);
                            if (uuid == null) {
                                if (f.isAnnotationPresent(AutoGenerated.class) && f.getAnnotation(AutoGenerated.class).strategy() == AutoGenerated.GenerationStrategy.RANDOM) {
                                    uuid = UUID.randomUUID();
                                    // Always make sure the model is up2date
                                    f.set(this, uuid);
                                } else {
                                    continue;
                                }
                            }
                            nc.setValue(Bytes.fromUuid(uuid).getBytes());
                        }
                    } else if (f.getType() instanceof java.lang.Object) {
                        if (f.get(this) == null) {
                            continue;
                        }
                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
                        ObjectOutput out = new ObjectOutputStream(bos);
                        out.writeObject(f.get(this));
                        out.close();
                        nc.setValue(bos.toByteArray());
                    }

                    // Key is to be inserted separately;
                    if (f.getName().equals(this.getKeyFieldName())) {
                        if (nc.getValue().length == 0) {
                            // Uhm ... ok, now what?
                            Logger.getLogger(getClass()).warn("Key field value was null");
                        } else {
                            keyFieldValue = nc.getValue().clone();
                        }
                    }
                    
                    columns.add(nc);
                } catch (IOException ex) {
                    Logger.getLogger(getClass()).log(Level.ERROR, "Object serialization failed", ex);
                } catch (IllegalAccessException ex) {
                    Logger.getLogger(getClass()).log(Level.ERROR, "Property not accessible", ex);
                }
            }
            
            if (keyFieldValue == null) {
                Logger.getLogger(getClass()).error("KeyFieldValue is null");
                return;
            }
            
            m.writeColumns(this.getColumnFamily(), Bytes.fromByteArray(keyFieldValue), columns);
            m.execute(ConsistencyLevel.ALL);
        } catch (Exception ex) {
            Logger.getLogger(Object.class.getName()).log(Level.ERROR, "Failed to insert object", ex);
        }
    }
    
    public void delete() {
        java.lang.Object keyFieldValue = null;
        try {
            keyFieldValue = getKeyField().get(this);
        } catch (IllegalArgumentException | IllegalAccessException ex) {
            Logger.getLogger(getClass()).log(Level.WARN, "Failed getting key field value", ex);
        }
        
        if (keyFieldValue == null) {
            throw new IllegalArgumentException("Key field value is null");
        }

        // Recover from deleting things under influence of boose
        if (Settings.getInstance().getString("SafeMode").equals("true")) {
            File dir = new File("junk/");
            if (!dir.isDirectory()) {
                if (!dir.mkdir()) {
                    throw new Error("Junk dir creation failed");
                }
            }

            // This isn't really aesthetical
            try (OutputStream fos = new FileOutputStream("junk/" + keyFieldValue); ObjectOutputStream oos = new ObjectOutputStream(fos)) {
                oos.writeObject(this);
            } catch (IOException ex) {
                Logger.getLogger(getClass()).log(Level.ERROR, "Junk object write failed", ex);
            }
        }
        
        RowDeletor r = DataPool.getRowDeletor();
        try {
            r.deleteRow(this.getColumnFamily(), Bytes.fromByteArray(getKeyValue(keyFieldValue)), ConsistencyLevel.ALL);
        } catch (Exception ex) {
            Logger.getLogger(getClass()).log(Level.ERROR, null, ex);
        }
    }
    
    public void get() {
        java.lang.Object keyFieldValue = null;
        try {
            keyFieldValue = getKeyField().get(this);
        } catch (IllegalArgumentException | IllegalAccessException ex) {
            Logger.getLogger(getClass()).log(Level.WARN, "Failed fetching key field value", ex);
        }
        this.get(keyFieldValue);
    }
    
    protected final byte[] getKeyValue(java.lang.Object keyFieldValue) {
        byte[] key = null;
        if (keyFieldValue instanceof String) {
            key = StringUtils.getBytesUtf8((String) keyFieldValue);
        } else if (keyFieldValue instanceof UUID) {
            key = Bytes.fromUuid((UUID) keyFieldValue).toByteArray();
        } else if (keyFieldValue instanceof ByteBuffer) {
            key = ((ByteBuffer) keyFieldValue).array();
        } else if (keyFieldValue instanceof Long) {
            key = Bytes.fromLong((Long) keyFieldValue).toByteArray();
        }
        return key;
    }
    
    public final void get(String keyFieldValue) {
        Field f = getKeyField();
        java.lang.Object kfv = null;
        switch (f.getType().getName()) {
            case "java.lang.String":
                kfv = keyFieldValue;
                break;
            case "int":
                kfv = Integer.parseInt(keyFieldValue);
                break;
            case "boolean":
                kfv = Boolean.parseBoolean(keyFieldValue);
                break;
            case "long":
                kfv = Long.parseLong(keyFieldValue);
                break;
            case "java.util.UUID":
                kfv = UUID.fromString(keyFieldValue);
                break;
        }
        get(kfv);
    }
    
    public final void get(java.lang.Object keyFieldValue) {
        if (keyFieldValue == null) {
            return;
        }
        
        byte[] key = getKeyValue(keyFieldValue);
        Selector s = DataPool.getSelector(this.getColumnFamily());
        List<Column> columns = null;
        try {
            columns = s.getColumnsFromRow(this.getColumnFamily(), Bytes.fromByteArray(key), Selector.newColumnsPredicateAll(false, 1000), ConsistencyLevel.ALL);
        } catch (Exception ex) {
            Logger.getLogger(getClass()).log(Level.WARN, "Could not retrieve object", ex);
        }
        
        getFromColumns(columns);
    }
    
    public final void getFromColumns(List<Column> columns) {
        for (Column c : columns) {
            for (Field f : ReflectionUtils.getAllFields(this.getClass())) {
                if (f.getName().equals(StringHelper.toUTF8(c.getName()))) {
                    f.setAccessible(true);
                    Bytes v = Bytes.fromByteArray(c.getValue());
                    try {
                        if (f.getType().getName().equals("java.lang.String")) {
                            f.set(this, StringHelper.toUTF8(c.getValue()));
                        } else if (f.getType().getName().equals("int")) {
                            f.set(this, c.value.getInt());
                        } else if (f.getType().getName().equals("boolean")) {
                            f.set(this, (c.getValue()[0] == 1 ? true : false));
                        } else if (f.getType().getName().equals("long")) {
                            f.set(this, v.toLong());
                        } else if (f.getType().getName().equals("java.util.UUID")) {
                            if (f.isAnnotationPresent(TimeUUID.class)) {
                                f.set(this, v.toTimeUuid());
                            } else {
                                f.set(this, v.toUuid());
                            }
                        } else if (f.getType() instanceof java.lang.Object) {
                            ByteArrayInputStream bis = new ByteArrayInputStream(c.getValue());
                            ObjectInput in = new ObjectInputStream(bis);
                            f.set(this, in.readObject());
                        }
                    } catch (IllegalArgumentException | IllegalAccessException | IOException | ClassNotFoundException ex) {
                        // All these things that can go wrong. I'm scared.
                        Logger.getLogger(getClass()).log(Level.WARN, "Could not rebuild object", ex);
                    }
                }
            }
        }
    }
    
    public Object() {
    }
    
    public Object(String key) {
        this.get(key);
    }
    
    public abstract String getColumnFamily();
    
    public abstract String getKeyFieldName();
    
    public Field getKeyField() {
        String kfn = getKeyFieldName();
        for (Field f : ReflectionUtils.getAllFields(this.getClass())) {
            if (f.getName().equals(kfn)) {
                f.setAccessible(true);
                return f;
            }
        }
        return null;
    }
    
    public boolean objectHasKey(String key) {
        String keyFieldName = getKeyFieldName();
        for (Field f : this.getClass().getDeclaredFields()) {
            if (f.getName().equals(keyFieldName)) {
                f.setAccessible(true);
                try {
                    return key.equals(f.get(this));
                } catch (IllegalArgumentException | IllegalAccessException ex) {
                    Logger.getLogger(getClass()).log(Level.ERROR, null, ex);
                }
            }
        }
        return false;
    }
    
    public void prepareForStorage() throws Exception {
        if (!DataPool.keySpaceExists(this.getColumnFamily())) {
            ColumnFamily.createFromObject(this);
        }
    }
}
